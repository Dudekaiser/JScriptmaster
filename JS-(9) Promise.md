## 9. Promise
* The general ```callback``` function pattern is difficult to read due to ```callback hell``` and has limitations in handling multiple asynchronous processes at once.
* ES6 introduced ```Promise``` for better asynchronous processing.

### 1) Syntax
```javascript
new Promise(executor);
```
<br>

* The execution function ```executor``` is called before the object that created by ```Promise``` generator is returned , and the ```executor``` function is executed at the moment the ```Promise``` is created.
* ```Promise``` object is created using ```new``` keyword and generator. The generator receives a ```callback``` function called ```executor``` as a parameter, and this ```callback``` function receives ```resolve``` and ```reject``` functions as arguments.
```javascript
const myFirstPromise = new Promise((resolve, reject) => {
  // do something asynchronous which eventually calls either:
  //
  //   resolve(someValue)        // fulfilled
  // or
  //   reject("failure reason")  // rejected
});
```
<br>

* ```Resolve``` function is called when an asynchronous task is successfully completed and the result is returned as a value, and ```reject``` function is called when the task fails and the cause of the error is returned.
* To add promise functionality to a function, simply return a ```promise```.
```javascript
function myAsyncFunction(url) {
  return new Promise((resolve, reject) => {
    const xhr = new XMLHttpRequest();
    xhr.open("GET", url);
    xhr.onload = () => resolve(xhr.responseText);
    xhr.onerror = () => reject(xhr.statusText);
    xhr.send();
  });
}
```
<br>

### 2) 3 states of promise
* These 3 states of ```promise``` mean procedure of ```promise``` processing.
* ```Promise``` is generated by ```new Promise()``` and there are 3 states until terminated.
  - Pending(wait) : Asynchronous processing logic has not yet completed
  - Fulfilled(implement) : Asynchronous processing is completed and the promise returns the result.
  - Rejectedd(fail) : Asynchronous processing fails or an error occurs
 
#### (1) Pending
* If ```new Promise()``` method is called, in state of ```Pending```.
```javascript
new Promise();
```
<br>

```javascript
new Promise(function (resolve, reject) {
 // ...
}};
```
<br>

#### (2) Fulfilled
* When argument of ```callback``` function ```resolve``` is executed, in state of ```Fulfilled```.
```javascript
new Promise(function (resolve, reject) {
  resolve();
});
```
<br>

* When ```Fulfilled``` is reached, we can receive result value of process by using Subsequent processing method ```then()```.

#### (3) Rejected
* When ```reject``` is called, in state of ```Reject```.
```javascript
new Promise(function (resolve, reject) {
  reject();
});
```
<br>

* When a failure state occurs, the failure processing result value can be received through the subsequent processing method ```catch()```.

### 3) subsequent processing method of ```Promise```
* Subsequent processing method is called depending on the state of the Promise object.
```javascript
promise
  .then((value) => {
    console.log(value);
  })
  .catch((error) => {
    console.log(error);
  })
  .finally(() => {
    console.log("finally");
  });
```
<br>

#### (1) ```then()```
* ```then()``` receives two ```callback``` functions as arguments.
* The first callback function is called when Fulfilled (fulfillment, the resolve function has been called), and the second function is called when Reject (failure, the reject function has been called).
* ```then``` method returns ```Promise```.
```javascript
.then(onFulfilled, onRejected);
```
<br>

```javascript
function getData() {
  return new Promise(function (resolve, reject) {
    var data = 100;
    resolve(data);
  });
}

// result value of resolve() "data" is received as "resolvedData"
getData().then(function (resolvedData) {
  console.log(resolvedData); // 100
});
```
<br>

#### (2) ```catch()```
* ```catch()``` is called when an exception (asynchronous processing or an error occurred in ```then``` method) occurs. The ```catch``` method returns ```Promise```.
```javscript
.catch(onRejected);
```
<br>

```javascript
function getData() {
  return new Promise(function (resolve, reject) {
    reject(new Error("Request is failed"));
  });
}

// result value of reject() "Error" received in err.
getData()
  .then()
  .catch(function (err) {
    console.log(err); // Error: Request is failed
  });
```
<br>

#### (3) ```finally()```
* When ```Promise``` is processed, the assigned ```callback``` function is executed regardless of the state.
```javascript
.finally(onFinally);

.finally(function() {
   // settled (fulfilled or rejected)
});
```
<br>

* But this is not offered in ```IE```.

### 4) Promise Chaining
* Asynchronous function that returns ```promise``` object can use the promise subsequent processing method ```then``` or ```catch``` method.
* We can chain multiple promises by that ```then``` method returns ```promise``` object.
```javascript
function getData() {
  return new Promise({
    // ...
  });
}

// with then() multiple promise linked
getData()
  .then(function (data) {
    // ...
  })
  .then(function () {
    // ...
  })
  .then(function () {
    // ...
  });
```
<br>

### 5) Error Handling
#### (1) With second argument of ```then()
```javascript
getData().then(handleSuccess, handleError);
```
<br>

#### (2) With ```catch()
```javascript
getData().then().catch();
```
<br>

* When ```catch``` is called, internal ```then(undefined, onRejected) is called.
```javascript
getData().catch(function (err) {
  console.log(err);
});

getData().then(undefined, function (err) {
  console.log(err);
});
```
<br>

* We can use ```then()``` but ```catch()``` is recommended to handle error. (more efficient)
<br>

```javascript
// An error which is not detected by 2nd argument of then()
function getData() {
  return new Promise(function (resolve, reject) {
    resolve("hi");
  });
}

getData().then(
  function (result) {
    console.log(result);
    throw new Error("Error in then()"); // Uncaught (in promise) Error: Error in then()
  },
  function (err) {
    console.log("then error : ", err);
  }
);
```
<br>

* The logic is processed normally by calling ```resolve()``` method, but if an error occurs inside the first ```callback``` function of ```then()```, the error is not caught properly.
```javascript
Uncaught (in promise) Error: Error in then()
```
<br>

* But if we handle with ```catch()```, it will be different result.
```javascript
getData()
  .then(function (result) {
    console.log(result); // hi
    throw new Error("Error in then()");
  })
  .catch(function (err) {
    console.log("then error : ", err); // then error :  Error: Error in then()
  });
```
<br>

* If we call ```catch``` method after calling all ```then``` methods, we can catch not only errors that occur in asynchronous processing (when the reject function is called), but also errors that occur within ```then``` method.
* Therefore, it is better to handle errors with ```catch()``` for better readability and more exception handling situations.
 


